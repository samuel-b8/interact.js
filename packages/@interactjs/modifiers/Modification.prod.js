import t from"../utils/clone.prod.js";import e from"../utils/extend.prod.js";import*as s from"../utils/rect.prod.js";export class Modification{states=[];startOffset={left:0,right:0,top:0,bottom:0};startDelta;result;endResult;startEdges;edges;interaction;constructor(t){this.interaction=t,this.result=o(),this.edges={left:!1,right:!1,top:!1,bottom:!1}}start({phase:t},s){const{interaction:r}=this,i=(t=>{const e=t.interactable.options[t.prepared.name],s=e.modifiers;return s&&s.length?s:["snap","snapSize","snapEdges","restrict","restrictEdges","restrictSize"].map((t=>{const s=e[t];return s&&s.enabled&&{options:s,methods:s._methods}})).filter((t=>!!t))})(r);this.prepareStates(i),this.startEdges=e({},r.edges),this.edges=e({},this.startEdges),this.startOffset=getRectOffset(r.rect,s),this.startDelta={x:0,y:0};const n=this.fillArg({phase:t,pageCoords:s,preEnd:!1});return this.result=o(),this.startAll(n),this.result=this.setAll(n)}fillArg(t){const{interaction:e}=this;return t.interaction=e,t.interactable=e.interactable,t.element=e.element,t.rect||=e.rect,t.edges||=this.startEdges,t.startOffset=this.startOffset,t}startAll(t){for(const e of this.states)e.methods.start&&(t.state=e,e.methods.start(t))}setAll(t){const{phase:r,preEnd:i,skipModifiers:n,rect:a,edges:l}=t;t.coords=e({},t.pageCoords),t.rect=e({},a),t.edges=e({},l);const c=n?this.states.slice(n):this.states,d=o(t.coords,t.rect);for(const o of c){var h;const{options:n}=o,a=e({},t.coords);let l=null;null!=(h=o.methods)&&h.set&&this.shouldDo(n,i,r)&&(t.state=o,l=o.methods.set(t),s.addEdges(t.edges,t.rect,{x:t.coords.x-a.x,y:t.coords.y-a.y})),d.eventProps.push(l)}e(this.edges,t.edges),d.delta.x=t.coords.x-t.pageCoords.x,d.delta.y=t.coords.y-t.pageCoords.y,d.rectDelta.left=t.rect.left-a.left,d.rectDelta.right=t.rect.right-a.right,d.rectDelta.top=t.rect.top-a.top,d.rectDelta.bottom=t.rect.bottom-a.bottom;const p=this.result.coords,f=this.result.rect;if(p&&f){const t=d.rect.left!==f.left||d.rect.right!==f.right||d.rect.top!==f.top||d.rect.bottom!==f.bottom;d.changed=t||p.x!==d.coords.x||p.y!==d.coords.y}return d}applyToInteraction(t){const{interaction:s}=this,{phase:o}=t,r=s.coords.cur,i=s.coords.start,{result:n,startDelta:a}=this,l=n.delta;"start"===o&&e(this.startDelta,n.delta);for(const[t,e]of[[i,a],[r,l]])t.page.x+=e.x,t.page.y+=e.y,t.client.x+=e.x,t.client.y+=e.y;const{rectDelta:c}=this.result,d=t.rect||s.rect;d.left+=c.left,d.right+=c.right,d.top+=c.top,d.bottom+=c.bottom,d.width=d.right-d.left,d.height=d.bottom-d.top}setAndApply(t){const{interaction:e}=this,{phase:s,preEnd:o,skipModifiers:r}=t,i=this.setAll(this.fillArg({preEnd:o,phase:s,pageCoords:t.modifiedCoords||e.coords.cur.page}));if(this.result=i,!i.changed&&(!r||r<this.states.length)&&e.interacting())return!1;if(t.modifiedCoords){const{page:s}=e.coords.cur,o={x:t.modifiedCoords.x-s.x,y:t.modifiedCoords.y-s.y};i.coords.x+=o.x,i.coords.y+=o.y,i.delta.x+=o.x,i.delta.y+=o.y}this.applyToInteraction(t)}beforeEnd(t){const{interaction:e,event:s}=t,o=this.states;if(!o||!o.length)return;let r=!1;for(const e of o){t.state=e;const{options:s,methods:o}=e,i=o.beforeEnd&&o.beforeEnd(t);if(i)return this.endResult=i,!1;r=r||!r&&this.shouldDo(s,!0,t.phase,!0)}r&&e.move({event:s,preEnd:!0})}stop(t){const{interaction:s}=t;if(!this.states||!this.states.length)return;const o=e({states:this.states,interactable:s.interactable,element:s.element,rect:null},t);this.fillArg(o);for(const t of this.states)o.state=t,t.methods.stop&&t.methods.stop(o);this.states=null,this.endResult=null}prepareStates(t){this.states=[];for(let e=0;e<t.length;e++){const{options:s,methods:o,name:r}=t[e];this.states.push({options:s,methods:o,index:e,name:r})}return this.states}restoreInteractionCoords({interaction:{coords:t,rect:e,modification:s}}){if(!s.result)return;const{startDelta:o}=s,{delta:r,rectDelta:i}=s.result,n=[[t.start,o],[t.cur,r]];for(const[t,e]of n)t.page.x-=e.x,t.page.y-=e.y,t.client.x-=e.x,t.client.y-=e.y;e.left-=i.left,e.right-=i.right,e.top-=i.top,e.bottom-=i.bottom}shouldDo(t,e,s,o){return!(!t||!1===t.enabled||o&&!t.endOnly||t.endOnly&&!e||"start"===s&&!t.setStart)}copyFrom(s){this.startOffset=s.startOffset,this.startDelta=s.startDelta,this.startEdges=s.startEdges,this.edges=s.edges,this.states=s.states.map((e=>t(e))),this.result=o(e({},s.result.coords),e({},s.result.rect))}destroy(){for(const t in this)this[t]=null}}function o(t,e){return{rect:e,coords:t,delta:{x:0,y:0},rectDelta:{left:0,right:0,top:0,bottom:0},eventProps:[],changed:!0}}export function getRectOffset(t,e){return t?{left:e.x-t.left,top:e.y-t.top,right:t.right-e.x,bottom:t.bottom-e.y}:{left:0,top:0,right:0,bottom:0}}
//# sourceMappingURL=Modification.prod.js.map