{
	"version": 3,
	"names": [
		"extend",
		"getOriginXY",
		"hypot",
		"is",
		"resolveRectLike",
		"rectToXY",
		"makeModifier",
		"snap",
		"start",
		"arg",
		"interaction",
		"interactable",
		"element",
		"rect",
		"state",
		"startOffset",
		"options",
		"origin",
		"offsetWithOrigin",
		"prepared",
		"name",
		"getOrigin",
		"x",
		"y",
		"snapOffset",
		"offset",
		"coords",
		"page",
		"offsetRect",
		"relativePoints",
		"offsets",
		"length",
		"map",
		"relativePoint",
		"index",
		"left",
		"width",
		"top",
		"height",
		"set",
		"targets",
		"relativeX",
		"relativeY",
		"len",
		"snapTarget",
		"target",
		"func",
		"_proxy",
		"push",
		"number",
		"range",
		"source",
		"closest",
		"inRange",
		"distance",
		"delta",
		"dx",
		"dy",
		"Infinity",
		"defaults",
		"endOnly",
		"enabled"
	],
	"sources": [
		"pointer.ts"
	],
	"sourcesContent": [
		"import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName, Point, RectResolvable, Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy<ActionName>,\n  offset: Offset,\n  index: number,\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets?: SnapTarget[]\n  // target range\n  range?: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints?: Point[]\n  // startCoords = offset snapping from drag start page position\n  offset?: Point | RectResolvable<[Interaction]> | 'startCoords'\n  offsetWithOrigin?: boolean\n  origin?: RectResolvable<[Element]> | Point\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<\n  SnapOptions,\n  {\n    offsets?: Offset[]\n    closest?: any\n    targetFields?: string[][]\n  }\n>\n\nfunction start(arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect && relativePoints && relativePoints.length\n      ? relativePoints.map((relativePoint, index) => ({\n          index,\n          relativePoint,\n          x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n          y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n        }))\n      : [\n          {\n            index: 0,\n            relativePoint: null,\n            x: snapOffset.x,\n            y: snapOffset.y,\n          },\n        ]\n}\n\nfunction set(arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable!, interaction.element!, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets: SnapPosition[] = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets!) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets!.length; index < len; index++) {\n      const snapTarget = options.targets![index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n          closest.inRange && range !== Infinity\n          ? // the pointer is relatively deeper in this target\n            distance / range < closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n            (range === Infinity && closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance\n        : // The other is not in range and the pointer is closer to this target\n          !closest.inRange && distance < closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin(arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n"
	],
	"mappings": "OAEOA,MAAY,oCACZC,MAAiB,yCACjBC,MAAW,mCACXC,MAAQ,mDACNC,cAAiBC,MAAgB,kDAEjCC,MAAoB,UAiM7B,MAUMC,EAAO,CACXC,MA3JaC,GACb,MAAMC,YAAEA,EAAWC,aAAEA,EAAYC,QAAEA,EAAOC,KAAEA,EAAIC,MAAEA,EAAKC,YAAEA,GAAgBN,GACnEO,QAAEA,GAAYF,EACdG,EAASD,EAAQE,iBAqIzB,CAAmBT,IACjB,MAAMG,QAAEA,GAAYH,EAAIC,YAIxB,OAHsBL,EAASD,EAAgBK,EAAIK,MAAME,QAAQC,OAAe,KAAM,KAAM,CAACL,MAC7DX,EAAYQ,EAAIE,aAAcC,EAASH,EAAIC,YAAYS,SAASC,KAGlG,EA3I4CC,CAAUZ,GAAO,CAAEa,EAAG,EAAGC,EAAG,GAEtE,IAAIC,EAEJ,GAAuB,gBAAnBR,EAAQS,OACVD,EAAa,CACXF,EAAGZ,EAAYgB,OAAOlB,MAAMmB,KAAKL,EACjCC,EAAGb,EAAYgB,OAAOlB,MAAMmB,KAAKJ,OAE9B,CACL,MAAMK,EAAaxB,EAAgBY,EAAQS,OAAed,EAAcC,EAAS,CAACF,IAElFc,EAAanB,EAASuB,IAAe,CAAEN,EAAG,EAAGC,EAAG,GAChDC,EAAWF,GAAKL,EAAOK,EACvBE,EAAWD,GAAKN,EAAOM,CACzB,CAEA,MAAMM,eAAEA,GAAmBb,EAE3BF,EAAMgB,QACJjB,GAAQgB,GAAkBA,EAAeE,OACrCF,EAAeG,KAAI,CAACC,EAAeC,KAAK,CACtCA,QACAD,gBACAX,EAAGP,EAAYoB,KAAOtB,EAAKuB,MAAQH,EAAcX,EAAIE,EAAWF,EAChEC,EAAGR,EAAYsB,IAAMxB,EAAKyB,OAASL,EAAcV,EAAIC,EAAWD,MAElE,CACE,CACEW,MAAO,EACPD,cAAe,KACfX,EAAGE,EAAWF,EACdC,EAAGC,EAAWD,GAG1B,EAsHEgB,IApHW9B,GACX,MAAMC,YAAEA,EAAWgB,OAAEA,EAAMZ,MAAEA,GAAUL,GACjCO,QAAEA,EAAOc,QAAEA,GAAYhB,EAEvBG,EAAShB,EAAYS,EAAYC,aAAeD,EAAYE,QAAUF,EAAYS,SAASC,MAC3FO,EAAO3B,EAAO,CAAC,EAAG0B,GAClBc,EAA0B,GAE3BxB,EAAQE,mBACXS,EAAKL,GAAKL,EAAOK,EACjBK,EAAKJ,GAAKN,EAAOM,GAGnB,IAAK,MAAME,KAAUK,EAAU,CAC7B,MAAMW,EAAYd,EAAKL,EAAIG,EAAOH,EAC5BoB,EAAYf,EAAKJ,EAAIE,EAAOF,EAElC,IAAK,IAAIW,EAAQ,EAAGS,EAAM3B,EAAQwB,QAAST,OAAQG,EAAQS,EAAKT,IAAS,CACvE,MAAMU,EAAa5B,EAAQwB,QAASN,GACpC,IAAIW,EAGFA,EADE1C,EAAG2C,KAAKF,GACDA,EAAWH,EAAWC,EAAWhC,EAAYqC,OAAQtB,EAAQS,GAE7DU,EAGNC,GAILL,EAAQQ,KAAK,CACX1B,GAAInB,EAAG8C,OAAOJ,EAAOvB,GAAKuB,EAAOvB,EAAImB,GAAahB,EAAOH,EACzDC,GAAIpB,EAAG8C,OAAOJ,EAAOtB,GAAKsB,EAAOtB,EAAImB,GAAajB,EAAOF,EAEzD2B,MAAO/C,EAAG8C,OAAOJ,EAAOK,OAASL,EAAOK,MAAQlC,EAAQkC,MACxDC,OAAQP,EACRV,QACAT,UAEJ,CACF,CAEA,MAAM2B,EAAU,CACdP,OAAQ,KACRQ,SAAS,EACTC,SAAU,EACVJ,MAAO,EACPK,MAAO,CAAEjC,EAAG,EAAGC,EAAG,IAGpB,IAAK,MAAMsB,KAAUL,EAAS,CAC5B,MAAMU,EAAQL,EAAOK,MACfM,EAAKX,EAAOvB,EAAIK,EAAKL,EACrBmC,EAAKZ,EAAOtB,EAAII,EAAKJ,EACrB+B,EAAWpD,EAAMsD,EAAIC,GAC3B,IAAIJ,EAAUC,GAAYJ,EAItBA,IAAUQ,KAAYN,EAAQC,SAAWD,EAAQF,QAAUQ,MAC7DL,GAAU,GAITD,EAAQP,UACRQ,EAEGD,EAAQC,SAAWH,IAAUQ,IAE3BJ,EAAWJ,EAAQE,EAAQE,SAAWF,EAAQF,MAE7CA,IAAUQ,KAAYN,EAAQF,QAAUQ,KAEzCJ,EAAWF,EAAQE,UAEpBF,EAAQC,SAAWC,EAAWF,EAAQE,YAE3CF,EAAQP,OAASA,EACjBO,EAAQE,SAAWA,EACnBF,EAAQF,MAAQA,EAChBE,EAAQC,QAAUA,EAClBD,EAAQG,MAAMjC,EAAIkC,EAClBJ,EAAQG,MAAMhC,EAAIkC,EAEtB,CAQA,OANIL,EAAQC,UACV3B,EAAOJ,EAAI8B,EAAQP,OAAOvB,EAC1BI,EAAOH,EAAI6B,EAAQP,OAAOtB,GAG5BT,EAAMsC,QAAUA,EACTA,CACT,EAuBEO,SAb4B,CAC5BT,MAAOQ,IACPlB,QAAS,KACTf,OAAQ,KACRP,kBAAkB,EAClBD,OAAQ,KACRY,eAAgB,KAChB+B,SAAS,EACTC,SAAS,mBAQIvD,EAAaC,EAAM,eACzBA"
}