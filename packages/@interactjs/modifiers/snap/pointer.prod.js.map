{
	"version": 3,
	"names": [
		"_extendProd",
		"_interopRequireDefault",
		"require",
		"_getOriginXYProd",
		"_hypotProd",
		"_isProd",
		"_rectProd",
		"_base",
		"obj",
		"__esModule",
		"default",
		"snap",
		"exports",
		"start",
		"arg",
		"interaction",
		"interactable",
		"element",
		"rect",
		"state",
		"startOffset",
		"options",
		"origin",
		"offsetWithOrigin",
		"rectToXY",
		"resolveRectLike",
		"getOriginXY",
		"prepared",
		"name",
		"getOrigin",
		"x",
		"y",
		"snapOffset",
		"offset",
		"coords",
		"page",
		"offsetRect",
		"relativePoints",
		"offsets",
		"length",
		"map",
		"relativePoint",
		"index",
		"left",
		"width",
		"top",
		"height",
		"set",
		"extend",
		"targets",
		"relativeX",
		"relativeY",
		"len",
		"snapTarget",
		"target",
		"is",
		"func",
		"_proxy",
		"push",
		"number",
		"range",
		"source",
		"closest",
		"inRange",
		"distance",
		"delta",
		"dx",
		"dy",
		"hypot",
		"Infinity",
		"defaults",
		"endOnly",
		"enabled",
		"makeModifier"
	],
	"sources": [
		"pointer.ts"
	],
	"sourcesContent": [
		"import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName, Point, RectResolvable, Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy<ActionName>,\n  offset: Offset,\n  index: number,\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets?: SnapTarget[]\n  // target range\n  range?: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints?: Point[]\n  // startCoords = offset snapping from drag start page position\n  offset?: Point | RectResolvable<[Interaction]> | 'startCoords'\n  offsetWithOrigin?: boolean\n  origin?: RectResolvable<[Element]> | Point\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<\n  SnapOptions,\n  {\n    offsets?: Offset[]\n    closest?: any\n    targetFields?: string[][]\n  }\n>\n\nfunction start(arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect && relativePoints && relativePoints.length\n      ? relativePoints.map((relativePoint, index) => ({\n          index,\n          relativePoint,\n          x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n          y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n        }))\n      : [\n          {\n            index: 0,\n            relativePoint: null,\n            x: snapOffset.x,\n            y: snapOffset.y,\n          },\n        ]\n}\n\nfunction set(arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable!, interaction.element!, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets: SnapPosition[] = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets!) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets!.length; index < len; index++) {\n      const snapTarget = options.targets![index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n          closest.inRange && range !== Infinity\n          ? // the pointer is relatively deeper in this target\n            distance / range < closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n            (range === Infinity && closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance\n        : // The other is not in range and the pointer is closer to this target\n          !closest.inRange && distance < closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin(arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n"
	],
	"mappings": "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"
}