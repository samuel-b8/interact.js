{
	"version": 3,
	"names": [
		"_cloneProd",
		"_interopRequireDefault",
		"require",
		"_extendProd",
		"rectUtils",
		"e",
		"r",
		"__esModule",
		"default",
		"t",
		"_getRequireWildcardCache",
		"has",
		"get",
		"n",
		"__proto__",
		"a",
		"Object",
		"defineProperty",
		"getOwnPropertyDescriptor",
		"u",
		"prototype",
		"hasOwnProperty",
		"call",
		"i",
		"set",
		"_interopRequireWildcard",
		"WeakMap",
		"obj",
		"createResult",
		"coords",
		"rect",
		"delta",
		"x",
		"y",
		"rectDelta",
		"left",
		"right",
		"top",
		"bottom",
		"eventProps",
		"changed",
		"getRectOffset",
		"exports",
		"Modification",
		"states",
		"startOffset",
		"startDelta",
		"result",
		"endResult",
		"startEdges",
		"edges",
		"interaction",
		"constructor",
		"this",
		"start",
		"phase",
		"pageCoords",
		"modifierList",
		"actionOptions",
		"interactable",
		"options",
		"prepared",
		"name",
		"actionModifiers",
		"modifiers",
		"length",
		"map",
		"type",
		"enabled",
		"methods",
		"_methods",
		"filter",
		"m",
		"getModifierList",
		"prepareStates",
		"extend",
		"arg",
		"fillArg",
		"preEnd",
		"startAll",
		"setAll",
		"element",
		"state",
		"skipModifiers",
		"unmodifiedRect",
		"unmodifiedEdges",
		"slice",
		"newResult",
		"_state$methods",
		"lastModifierCoords",
		"returnValue",
		"shouldDo",
		"addEdges",
		"push",
		"prevCoords",
		"prevRect",
		"rectChanged",
		"applyToInteraction",
		"curCoords",
		"cur",
		"startCoords",
		"curDelta",
		"coordsSet",
		"page",
		"client",
		"width",
		"height",
		"setAndApply",
		"modifiedCoords",
		"interacting",
		"adjustment",
		"beforeEnd",
		"event",
		"doPreend",
		"endPosition",
		"move",
		"stop",
		"modifierArg",
		"index",
		"restoreInteractionCoords",
		"modification",
		"coordsAndDeltas",
		"requireEndOnly",
		"endOnly",
		"setStart",
		"copyFrom",
		"other",
		"s",
		"clone",
		"destroy",
		"prop"
	],
	"sources": [
		"Modification.ts"
	],
	"sourcesContent": [
		"import type { EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoAnyPhaseArg } from '@interactjs/core/Interaction'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/core/types'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { Modifier, ModifierArg, ModifierState } from './types'\n\nexport interface ModificationResult {\n  delta: Point\n  rectDelta: Rect\n  coords: Point\n  rect: FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: EventPhase\n  pageCoords: Point\n  rect: FullRect\n  coords: Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport class Modification {\n  states: ModifierState[] = []\n  startOffset: Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta!: Point\n  result!: ModificationResult\n  endResult!: Point\n  startEdges!: EdgeOptions\n  edges: EdgeOptions\n  readonly interaction: Readonly<Interaction>\n\n  constructor(interaction: Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n    this.edges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n  }\n\n  start({ phase }: { phase: EventPhase }, pageCoords: Point) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.startEdges = extend({}, interaction.edges)\n    this.edges = extend({}, this.startEdges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg = this.fillArg({\n      phase,\n      pageCoords,\n      preEnd: false,\n    })\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = (this.result = this.setAll(arg))\n\n    return result\n  }\n\n  fillArg(arg: Partial<ModifierArg>) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect ||= interaction.rect\n    arg.edges ||= this.startEdges\n    arg.startOffset = this.startOffset\n\n    return arg as ModifierArg\n  }\n\n  startAll(arg: MethodArg & Partial<ModifierArg>) {\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll(arg: MethodArg & Partial<ModifierArg>): ModificationResult {\n    const { phase, preEnd, skipModifiers, rect: unmodifiedRect, edges: unmodifiedEdges } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n    arg.edges = extend({}, unmodifiedEdges)\n\n    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods?.set && this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg<never>)\n\n        rectUtils.addEdges(arg.edges, arg.rect, {\n          x: arg.coords.x - lastModifierCoords.x,\n          y: arg.coords.y - lastModifierCoords.y,\n        })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    extend(this.edges, arg.edges)\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords && prevRect) {\n      const rectChanged =\n        newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed =\n        rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction(arg: { phase: EventPhase; rect?: Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [\n      [startCoords, startDelta],\n      [curCoords, curDelta],\n    ] as const) {\n      coordsSet.page.x += delta.x\n      coordsSet.page.y += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left += rectDelta.left\n    rect.right += rectDelta.right\n    rect.top += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply(\n    arg: Partial<DoAnyPhaseArg> & {\n      phase: EventPhase\n      preEnd?: boolean\n      skipModifiers?: number\n      modifiedCoords?: Point\n    },\n  ): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll(\n      this.fillArg({\n        preEnd,\n        phase,\n        pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n      }),\n    )\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (\n      !result.changed &&\n      (!skipModifiers || skipModifiers < this.states.length) &&\n      interaction.interacting()\n    ) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd(arg: Omit<DoAnyPhaseArg, 'iEvent'> & { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd && methods.beforeEnd(arg as unknown as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend && this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop(arg: { interaction: Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial<ModifierArg> = extend(\n      {\n        states: this.states,\n        interactable: interaction.interactable,\n        element: interaction.element,\n        rect: null,\n      },\n      arg,\n    )\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) {\n        state.methods.stop(modifierArg as ModifierArg)\n      }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates(modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index < modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords({ interaction: { coords, rect, modification } }: { interaction: Interaction }) {\n    if (!modification.result) return\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo(options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      !options ||\n      options.enabled === false ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly && !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly && !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' && !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom(other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.startEdges = other.startEdges\n    this.edges = other.edges\n    this.states = other.states.map((s) => clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy() {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult(coords?: Point, rect?: FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList(interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map((type) => {\n      const options = actionOptions[type]\n\n      return (\n        options &&\n        options.enabled && {\n          options,\n          methods: options._methods,\n        }\n      )\n    })\n    .filter((m) => !!m)\n}\n\nexport function getRectOffset(rect, coords) {\n  return rect\n    ? {\n        left: coords.x - rect.left,\n        top: coords.y - rect.top,\n        right: rect.right - coords.x,\n        bottom: rect.bottom - coords.y,\n      }\n    : {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n      }\n}\n"
	],
	"mappings": "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"
}