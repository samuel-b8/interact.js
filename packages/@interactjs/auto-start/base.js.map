{
	"version": 3,
	"names": [
		"domUtils",
		"_interopRequireWildcard",
		"require",
		"_extend",
		"_interopRequireDefault",
		"_is",
		"_misc",
		"_InteractableMethods",
		"obj",
		"__esModule",
		"default",
		"_getRequireWildcardCache",
		"e",
		"WeakMap",
		"r",
		"t",
		"has",
		"get",
		"n",
		"__proto__",
		"a",
		"Object",
		"defineProperty",
		"getOwnPropertyDescriptor",
		"u",
		"prototype",
		"hasOwnProperty",
		"call",
		"i",
		"set",
		"install",
		"scope",
		"interactStatic",
		"interact",
		"defaults",
		"usePlugin",
		"InteractableMethods",
		"base",
		"actionChecker",
		"styleCursor",
		"extend",
		"perAction",
		"manualStart",
		"max",
		"Infinity",
		"maxPerElement",
		"allowFrom",
		"ignoreFrom",
		"mouseButtons",
		"maxInteractions",
		"newValue",
		"autoStart",
		"withinInteractionLimit",
		"cursorElement",
		"prepareOnDown",
		"interaction",
		"pointer",
		"event",
		"eventTarget",
		"interacting",
		"actionInfo",
		"getActionInfo",
		"prepare",
		"prepareOnMove",
		"pointerType",
		"pointerIsDown",
		"startOnMove",
		"arg",
		"pointerWasMoved",
		"prepared",
		"name",
		"fire",
		"interactable",
		"actionName",
		"options",
		"element",
		"stop",
		"start",
		"setInteractionCursor",
		"clearCursorOnStop",
		"setCursor",
		"validateAction",
		"action",
		"testIgnoreAllow",
		"enabled",
		"validateMatches",
		"matches",
		"matchElements",
		"len",
		"length",
		"match",
		"matchElement",
		"matchAction",
		"getAction",
		"pushMatches",
		"push",
		"is",
		"interactables",
		"forEachMatch",
		"parentNode",
		"copyAction",
		"rect",
		"getRect",
		"maxActions",
		"autoStartMax",
		"activeInteractions",
		"interactableCount",
		"elementCount",
		"interactions",
		"list",
		"otherAction",
		"number",
		"cursor",
		"prevCursorElement",
		"style",
		"ownerDocument",
		"documentElement",
		"cursorChecker",
		"func",
		"_interacting",
		"actions",
		"map",
		"getCursor",
		"id",
		"before",
		"listeners",
		"interactions:move",
		"_default",
		"exports"
	],
	"sources": [
		"base.ts"
	],
	"sourcesContent": [
		"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type {\n  CursorChecker,\n  PointerType,\n  PointerEventType,\n  Element,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './InteractableMethods'\nimport InteractableMethods from './InteractableMethods'\n/* eslint-enable import/no-duplicates */\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    /**\n     * Returns or sets the maximum number of concurrent interactions allowed.  By\n     * default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables and\n     * elements, you need to enable it in the draggable, resizable and gesturable\n     * `'max'` and `'maxPerElement'` options.\n     *\n     * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n     */\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install(scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove(arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName>(\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches(interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare(\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName>(\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions(newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor(element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName>(interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n"
	],
	"mappings": "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"
}