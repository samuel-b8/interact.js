{
	"version": 3,
	"names": [
		"domUtils",
		"e",
		"r",
		"__esModule",
		"default",
		"t",
		"_getRequireWildcardCache",
		"has",
		"get",
		"n",
		"__proto__",
		"a",
		"Object",
		"defineProperty",
		"getOwnPropertyDescriptor",
		"u",
		"prototype",
		"hasOwnProperty",
		"call",
		"i",
		"set",
		"_interopRequireWildcard",
		"require",
		"_extendProd",
		"_interopRequireDefault",
		"_isProd",
		"_miscProd",
		"_InteractableMethods",
		"obj",
		"WeakMap",
		"validateAction",
		"action",
		"interactable",
		"element",
		"eventTarget",
		"scope",
		"testIgnoreAllow",
		"options",
		"name",
		"enabled",
		"withinInteractionLimit",
		"validateMatches",
		"interaction",
		"pointer",
		"event",
		"matches",
		"matchElements",
		"len",
		"length",
		"match",
		"matchElement",
		"matchAction",
		"getAction",
		"getActionInfo",
		"pushMatches",
		"push",
		"is",
		"interactables",
		"forEachMatch",
		"actionInfo",
		"manualStart",
		"parentNode",
		"prepare",
		"copyAction",
		"prepared",
		"rect",
		"getRect",
		"setInteractionCursor",
		"fire",
		"maxActions",
		"max",
		"maxPerElement",
		"autoStartMax",
		"autoStart",
		"maxInteractions",
		"activeInteractions",
		"interactableCount",
		"elementCount",
		"interactions",
		"list",
		"otherAction",
		"interacting",
		"newValue",
		"number",
		"this",
		"setCursor",
		"cursor",
		"cursorElement",
		"prevCursorElement",
		"style",
		"ownerDocument",
		"documentElement",
		"pointerType",
		"styleCursor",
		"cursorChecker",
		"func",
		"_interacting",
		"actions",
		"map",
		"getCursor",
		"id",
		"before",
		"install",
		"interactStatic",
		"interact",
		"defaults",
		"usePlugin",
		"InteractableMethods",
		"base",
		"actionChecker",
		"extend",
		"perAction",
		"Infinity",
		"allowFrom",
		"ignoreFrom",
		"mouseButtons",
		"listeners",
		"prepareOnDown",
		"arg",
		"pointerIsDown",
		"prepareOnMove",
		"pointerWasMoved",
		"actionName",
		"stop",
		"start",
		"startOnMove",
		"clearCursorOnStop",
		"exports"
	],
	"sources": [
		"base.ts"
	],
	"sourcesContent": [
		"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type {\n  CursorChecker,\n  PointerType,\n  PointerEventType,\n  Element,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './InteractableMethods'\nimport InteractableMethods from './InteractableMethods'\n/* eslint-enable import/no-duplicates */\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    /**\n     * Returns or sets the maximum number of concurrent interactions allowed.  By\n     * default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables and\n     * elements, you need to enable it in the draggable, resizable and gesturable\n     * `'max'` and `'maxPerElement'` options.\n     *\n     * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n     */\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install(scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove(arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName>(\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches(interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare(\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName>(\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions(newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor(element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName>(interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n"
	],
	"mappings": "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"
}