{
	"version": 3,
	"names": [
		"element",
		"selector",
		"is",
		"matchesSelector",
		"parentNode",
		"correspondingUseElement",
		"clientRect",
		"getElementClientRect",
		"browser",
		"isIOS7",
		"scroll",
		"getScrollXY",
		"win",
		"getWindow",
		"left",
		"x",
		"right",
		"top",
		"y",
		"bottom",
		"node",
		"path",
		"push",
		"elements",
		"deepestNodeIndex",
		"deepestNodeParents",
		"i",
		"length",
		"currentNode",
		"deepestNode",
		"currentNodeParent",
		"getParent",
		"deepestNodeParent",
		"ownerDocument",
		"higherNode",
		"lowerNode",
		"parseInt",
		"getComputedStyle",
		"zIndex",
		"ancestryStart",
		"getNodeParents",
		"domObjects",
		"HTMLElement",
		"SVGElement",
		"SVGSVGElement",
		"ownerSVGElement",
		"currentNodeParents",
		"commonIndex",
		"parents",
		"child",
		"lastChild",
		"previousSibling",
		"limit",
		"parent",
		"contains",
		"value",
		"string",
		"document",
		"querySelector",
		"_browser",
		"_interopRequireDefault",
		"require",
		"_domObjects",
		"_is",
		"e",
		"r",
		"__esModule",
		"default",
		"t",
		"_getRequireWildcardCache",
		"has",
		"get",
		"n",
		"__proto__",
		"a",
		"Object",
		"defineProperty",
		"getOwnPropertyDescriptor",
		"u",
		"prototype",
		"hasOwnProperty",
		"call",
		"set",
		"_interopRequireWildcard",
		"WeakMap",
		"obj",
		"docFrag",
		"host",
		"window",
		"realWindow",
		"replace",
		"prefixedMatchesSelector",
		"el",
		"parentParent",
		"unshift",
		"relevantWindow",
		"scrollX",
		"documentElement",
		"scrollLeft",
		"scrollY",
		"scrollTop",
		"getBoundingClientRect",
		"getClientRects",
		"width",
		"height"
	],
	"sources": [
		"domUtils.ts"
	],
	"sourcesContent": [
		"import type { Rect, Target, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains(parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest(element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode(node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector(element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement(elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents(node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan(higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo(element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement(element: Element) {\n  return (element as any).correspondingUseElement || element\n}\n\nexport function getScrollXY(relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect(element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect(element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath(node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector(value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n"
	],
	"mappings": "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"
}