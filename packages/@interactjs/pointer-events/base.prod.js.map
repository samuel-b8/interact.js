{
	"version": 3,
	"names": [
		"domUtils",
		"e",
		"r",
		"__esModule",
		"default",
		"t",
		"_getRequireWildcardCache",
		"has",
		"get",
		"n",
		"__proto__",
		"a",
		"Object",
		"defineProperty",
		"getOwnPropertyDescriptor",
		"u",
		"prototype",
		"hasOwnProperty",
		"call",
		"i",
		"set",
		"_interopRequireWildcard",
		"require",
		"_extendProd",
		"_interopRequireDefault",
		"_getOriginXYProd",
		"_PointerEvent",
		"obj",
		"WeakMap",
		"pointerEvents",
		"id",
		"before",
		"install",
		"scope",
		"defaults",
		"actions",
		"extend",
		"phaselessTypes",
		"types",
		"listeners",
		"addInteractionProps",
		"interaction",
		"prevTap",
		"tapTime",
		"addHoldInfo",
		"down",
		"pointerInfo",
		"hold",
		"duration",
		"Infinity",
		"timeout",
		"moveAndClearHold",
		"arg",
		"pointer",
		"event",
		"eventTarget",
		"duplicate",
		"pointerIsDown",
		"pointerWasMoved",
		"clearHold",
		"fire",
		"type",
		"pointerIndex",
		"timer",
		"pointers",
		"path",
		"getPath",
		"signalArg",
		"targets",
		"node",
		"length",
		"minDuration",
		"target",
		"holdDuration",
		"eventable",
		"options",
		"setTimeout",
		"downAndStartHold",
		"tapAfterUp",
		"PointerEvent",
		"collectEventTargets",
		"ignoreFrom",
		"allowFrom",
		"origin",
		"x",
		"y",
		"move",
		"up",
		"cancel",
		"tap",
		"doubletap",
		"pointerEvent",
		"now",
		"prop",
		"props",
		"getOriginXY",
		"_subtractOrigin",
		"currentTarget",
		"_addOrigin",
		"immediatePropagationStopped",
		"propagationStopped",
		"double",
		"timeStamp",
		"getPointerIndex",
		"downTarget",
		"filter",
		"_interaction$pointers",
		"_interaction$pointers2",
		"clearTimeout",
		"exports"
	],
	"sources": [
		"base.ts"
	],
	"sourcesContent": [
		"import type { Eventable } from '@interactjs/core/Eventable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Point, PointerType, PointerEventType, Element } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\n\nimport { PointerEvent } from './PointerEvent'\n\nexport type EventTargetList = Array<{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}>\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Point | string | Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    pointerEvents: Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent<any> }\n    'pointerEvents:fired': {\n      interaction: Interaction<null>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      pointerEvent: PointerEvent<any>\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction<any>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom: null,\n  allowFrom: null,\n  origin: { x: 0, y: 0 },\n}\n\nconst pointerEvents: Plugin = {\n  id: 'pointer-events/base',\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) => {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire<T extends string>(\n  arg: {\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    interaction: Interaction<never>\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Scope,\n) {\n  const { interaction, pointer, event, eventTarget, type, targets = collectEventTargets(arg, scope) } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      ;(pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (\n      pointerEvent.immediatePropagationStopped ||\n      (pointerEvent.propagationStopped &&\n        i + 1 < targets.length &&\n        targets[i + 1].node !== pointerEvent.currentTarget)\n    ) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire(\n          {\n            interaction,\n            pointer,\n            event,\n            eventTarget,\n            type: 'doubletap',\n          },\n          scope,\n        )\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string>(\n  {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n  }: {\n    interaction: Interaction<any>\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    type: T\n  },\n  scope: Scope,\n) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (\n    type === 'tap' &&\n    (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))\n  ) {\n    return []\n  }\n\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(\n      (target) =>\n        target.eventable.options.holdDuration === interaction.pointers[pointerIndex]?.hold?.duration,\n    )\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps({ interaction }) {\n  interaction.prevTap = null // the most recent tap event on this interaction\n  interaction.tapTime = 0 // time of the most recent tap event\n}\n\nfunction addHoldInfo({ down, pointerInfo }: SignalArgs['interactions:update-pointer']) {\n  if (!down && pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold({ interaction, pointerIndex }) {\n  const hold = interaction.pointers[pointerIndex].hold\n\n  if (hold && hold.timeout) {\n    clearTimeout(hold.timeout)\n    hold.timeout = null\n  }\n}\n\nfunction moveAndClearHold(arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\n\n  if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearHold(arg)\n    }\n\n    fire(\n      {\n        interaction,\n        pointer,\n        event,\n        eventTarget: eventTarget as Element,\n        type: 'move',\n      },\n      scope,\n    )\n  }\n}\n\nfunction downAndStartHold(\n  { interaction, pointer, event, eventTarget, pointerIndex }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  const timer = interaction.pointers[pointerIndex].hold!\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) return\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() => {\n    fire(\n      {\n        interaction,\n        eventTarget,\n        pointer,\n        event,\n        type: 'hold',\n      },\n      scope,\n    )\n  }, minDuration)\n}\n\nfunction tapAfterUp(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:up'],\n  scope: Scope,\n) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install(scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n"
	],
	"mappings": "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"
}