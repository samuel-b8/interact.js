{
	"version": 3,
	"names": [
		"dom",
		"finder",
		"methodOrder",
		"search",
		"details",
		"method",
		"interaction",
		"simulationResume",
		"pointerType",
		"eventType",
		"eventTarget",
		"scope",
		"test",
		"interactions",
		"list",
		"element",
		"simulation",
		"allowResume",
		"parentNode",
		"mouseOrPen",
		"pointerId",
		"firstNonActive",
		"hasPointerId",
		"interacting",
		"hasPointer",
		"idle",
		"pointers",
		"length",
		"target",
		"interactable",
		"options",
		"gesture",
		"enabled",
		"some",
		"id"
	],
	"sources": [
		"interactionFinder.ts"
	],
	"sourcesContent": [
		"import * as dom from '@interactjs/utils/domUtils'\n\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/core/types'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search(details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId(interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n"
	],
	"mappings": "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"
}